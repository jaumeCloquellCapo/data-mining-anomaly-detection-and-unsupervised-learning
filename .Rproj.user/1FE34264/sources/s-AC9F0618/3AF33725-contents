---
title: "Untitled"
output: html_document
---

```{r setup, include=FALSE}
library(grid) 
library(gridExtra)
library(tidyverse)
library(dummies)
library(readxl)
library(knitr)
library(ggplot2)
library(lubridate)
library(arules)
library(arulesViz)
library(plyr)
library(corrplot)
knitr::opts_chunk$set(echo = TRUE)
```

## Introducción al dataset

Para la práctica de reglas de asociación de la asignatura *"Minería de Datos: Detección de Anomálias y  Aprendizaje no Supervisado"* se ha utilizado un dataset recuperado de la web de UCI. El objetivo des predecir la nota final G3 de un conjunto de datos de alumnos dado. Para ello generaramos dos modelos machine learning a partir de un análisis descriptivo y exploratorio utilizando un metodo no supervisado. Los datos los obtenemos en https://archive.ics.uci.edu/ml/datasets/Student+Performance.

Vamos a trabajar únicamente con el dataset de la asignatura de portugués
```{r}
studentMat <- read.table("student/student-mat.csv", row.names=NULL, sep=";", header=TRUE)
studentPor <- read.table("student/student-por.csv", row.names=NULL, sep=";", header=TRUE)
```

## Análisis exploratorio

Vamos a comprobar si tenemos datos completos en los datos, ya que los valores perdidos siempre pueden causar problemas. 

```{r}
any(is.na(studentPor))
```

Vemos que no hay valores perdidos por lo que el siguiente paso será ver de que tipo son nuestros datos, así como sus distribuciones para comenzar a hacernos una idea de que es lo que tenemos entre manos. Parece que tenemos una combinación entre factores y variables numéricas.

```{r}
str(studentPor)
table(sapply(studentPor, class))
```

Vemos que tenemos 33, 17 factores que trataremos a continuación y el resto poseen valores enteros. De las 16 variables de tipo enteros, todas ellas son variables categóricas categóricas que trataremos más adelante.


Para ver lo correladas que están unas variables con otras, y también con G3, podemos calcular y dibujar una matriz de correlación. Primero creamos variables dummies para las variables de tipo factor que queramos incluir en la matriz de correlación. 

```{r}
names(studentPor) <- tolower(names(studentPor))
studentPor$pass <- ifelse(studentPor$g3 > 9, 1, 0) #variable a predecir

studentPor.numeric <- studentPor
#studentPor.numeric$pass <- ifelse(studentPor$g3 > 9, 1, 0) #variable a predecir

studentPor.numeric$school <- as.numeric(studentPor$school)
studentPor.numeric$address <- as.numeric(studentPor$address)
studentPor.numeric$pstatus <- as.numeric(studentPor$pstatus)
studentPor.numeric$sex <- as.numeric(studentPor$sex)
studentPor.numeric$famsize <- as.numeric(studentPor$famsize)

# yes / no
studentPor.numeric$schoolsup <- as.numeric(studentPor$schoolsup) - 1
studentPor.numeric$famsup <- as.numeric(studentPor$famsup) - 1
studentPor.numeric$paid <- as.numeric(studentPor$paid) - 1
studentPor.numeric$activities <- as.numeric(studentPor$activities) - 1
studentPor.numeric$higher <- as.numeric(studentPor$higher) - 1
studentPor.numeric$internet <- as.numeric(studentPor$internet) - 1
studentPor.numeric$romantic <- as.numeric(studentPor$romantic) - 1
studentPor.numeric$nursery <- as.numeric(studentPor$nursery) - 1


studentPor.numeric$reason <- as.numeric(studentPor$reason)
studentPor.numeric$guardian <- as.numeric(studentPor$guardian)
studentPor.numeric$fjob <- as.numeric(studentPor$fjob)
studentPor.numeric$mjob <- as.numeric(studentPor$mjob)
studentPor.numeric <- as.data.frame(studentPor.numeric)
```


```{r}
icorrplot <- function (dataset) {
  cor.mtest <- function(mat, ...) {
    mat <- as.matrix(mat)
    n <- ncol(mat)
    p.mat<- matrix(NA, n, n)
    diag(p.mat) <- 0
    for (i in 1:(n - 1)) {
      for (j in (i + 1):n) {
        tmp <- cor.test(mat[, i], mat[, j], ...)
        p.mat[i, j] <- p.mat[j, i] <- tmp$p.value
      }
    }
    colnames(p.mat) <- rownames(p.mat) <- colnames(mat)
    p.mat
  }
  # matrix of the p-value of the correlation
  p.mat <- cor.mtest(dataset)
  col <- colorRampPalette(c("#BB4444", "#EE9988", "#FFFFFF", "#77AADD", "#4477AA"))
  M <- cor(dataset)
  cex.before <- par("cex")
  par(cex = 0.1)
  corrplot(M, method="color", col=col(200),  
           type="upper",
           addCoef.col = "grey", # Add coefficient of correlation
           tl.cex = 1/par("cex"),
           cl.cex = 1/par("cex"),
           tl.col="black", 
           tl.srt=45, #Text label color and rotation
           # Combine with significance
           p.mat = p.mat, 
           sig.level = 0.05,
           addCoefasPercent = TRUE,
           # hide correlation coefficient on the principal diagonal
           diag=FALSE 
  )
  par(cex = cex.before)
}
```

Aqui ya podemos ver de un simple vistazo que variable poseen un alto nivel de correlación y por tanto serán con las que trabjaremos en los siguientes análisis.

El nivel educativo de los padres tiene un alto nivel de correlación.

```{r}
ggplot(studentPor, aes(medu)) + geom_bar() + facet_wrap(~ pass) + ggtitle ("Diagrama barras educacion materno, por nota final")

ggplot(studentPor, aes(fedu)) + geom_bar() + facet_wrap(~ pass) + ggtitle ("Diagrama barras educacion paterno, por nota final")
```


Sería conveniente una clasificación más detallada de las profesiones de las madres de los alumnos. Puede guardar alguna relación con la nota final, seguramente en combinación con otras variables, pero hay muchas instancias de “Other”.

Hemos utilizado un diagrama de barras para ver la distribución de trabajos de las madres/padres de los estudiantes. Vemos que la barra mayor es la correspondiente a “other”, por lo que si hubiera posibilidad de obtener mejores datos, podríamos sugerir clasificar con más granularidad los trabajos.

```{r}
qplot(factor(studentPor$mjob), main = "Diagrama de barras trabajos de las madres")
qplot(factor(studentPor$fjob), main = "Diagrama de barras trabajos de las madres")

ggplot(studentPor, aes(mjob)) + geom_bar() + facet_wrap(~ pass) + ggtitle ("Diagrama barras trabajo materno, por nota final")

ggplot(studentPor, aes(fjob)) + geom_bar() + facet_wrap(~ pass) + ggtitle ("Diagrama barras trabajo paterno, por nota final")
```


Se espera que las variables G1 y G2 sean determinantes para un modelo de predicción de G3 como target, es decir, que las calificaciones pasadas de los alumnos influirán en su nota final.

```{r}
ggplot(studentPor, aes(x = g1)) + geom_histogram(binwidth = 1, fill = "white", colour = "black") + facet_grid(pass ~ .) + ggtitle ("Histograma G1 por nota final")

ggplot(studentPor, aes(x = g2)) + geom_histogram(binwidth = 1, fill = "white", colour = "black") + facet_grid(pass ~ .) + ggtitle ("Histograma G2 por clasificación nota final")
```

La dedicación de los alumnos a salir con amigos no resultar influyente a la hora de su calificación final.

La dirección (address) del alumno posee cierta correlación con la nota final. A primera vista, es dificil entender dar una explicación de dicha correlación aunque puede que esta influya directamente con otra variable. Por ejemplo, el hecho que viva en el campo o en la ciudad influye bastante en el tipo los estudios de sus padres.

```{r}
ggplot(studentPor, aes(address)) + geom_bar() + facet_wrap(~ pass) + ggtitle ("Diagrama barras address, por nota final")
```


Se percibe una correlación entre los alumnos que aprueban y los que tienen aspiraciones de estudiar estudios superiores (higuer)

```{r}
ggplot(studentPor, aes(higher)) + geom_bar() + facet_wrap(~ pass) + ggtitle ("Diagrama barras educacion aspiraciones de estudiar estudios superiores, por nota final")
```



Como es lógico la dedicación al estudio influye con el aprobado y el suspendo. Esta variable, al no poseer información relevante, la descartaremos para así evitar que se generen reglas que no aporten valor.

```{r}
ggplot(studentPor, aes(studytime)) + geom_bar() + facet_wrap(~ pass) + ggtitle ("Diagrama barras studytime, por nota final") 
```

Los alumnos con relación amorosa o no, es determinante a la hora de aprobar. Como se aprecia en el plot, influye negativamente que el alumno se encuentre dentro de una relación amorosa.

```{r}
ggplot(studentPor, aes(romantic)) + geom_bar() + facet_wrap(~ pass) + ggtitle ("Diagrama barras romantic, por nota final")
```

Las  menos correladas están son failures, school, age o walc entre otras. Estas las descartaremos en los siguientes análisis.



```{r}
aso.student <- studentPor %>% select(medu, fedu, famsup, pass, romantic, higher)
aso.student <- data.frame(sapply(aso.student, as.factor))
```

```{r}
aso.student.trans <- as(aso.student, "transactions")
summary(aso.student.trans)
itemFrequencyPlot(aso.student.trans, support = 0.1, cex.names=0.8)
itemFrequencyPlot(aso.student.trans, support = 0.01, cex.names=0.8)
```

```{r}
deleteRebundantRules <- function (rules) {
  subsetMatrix <- is.subset(rules, aso.student.rules.sorted)
  subsetMatrix[lower.tri(subsetMatrix, diag=TRUE)] <- FALSE
  redundant <- colSums(subsetMatrix, na.rm=TRUE) >= 1
  rules <- rules[!redundant]
  return (rules)
}

createRules <- function (dt, supp = 0.1, conf = 0.8, minlen=2, maxlen=5) {
  rules <- apriori(dt, parameter = list(supp = 0.1 , conf = 0.8, minlen=minlen, maxlen=maxlen), appearance = list(rhs = c("pass=1", "pass=0")))

  mInteres <- interestMeasure(rules, measure=c("hyperConfidence", "leverage","phi", "gini"), transactions=aso.student)
  quality(rules) <- cbind(quality(rules), mInteres)
  
  rules <- deleteRebundantRules(rules)
  return (rules)
}

plotRules <- function(rules) {
  plot(rules)
  plot(rules, method="graph")
  plot(rules, method="grouped")
  plot(rules, method="paracoord", reorder=TRUE)
}
```


```{r}
aso.student.rules <- createRules(aso.student)
#Ordenamos los ítems por soporte descendente
aso.student.rules.sorted <- sort(aso.student.rules, by="lift")
inspect(aso.student.rules.sorted)
plotRules(aso.student.rules.sorted)
```


Si quisieramos acotar y seguir analizando los ítemsets frecuentes, podríamos usar rangos definidos por las variables **minlen** y **maxlen** para definir cuantos ítems queremos que formen los sets. 



```{r}
studentPor$meduBin <- ifelse(studentPor$medu < 2, 0, 1)
studentPor$feduBin <- ifelse(studentPor$fedu < 2, 0, 1)

aso.student.2 <- studentPor %>% select(meduBin, feduBin, famsup, pass, romantic, higher)
aso.student.2 <- data.frame(sapply(aso.student.2, as.factor))

aso.student.2.rules <- createRules(aso.student.2)
#Ordenamos los ítems por soporte descendente
aso.student.rules.2.sorted <- sort(aso.student.2.rules, by="lift")
inspect(aso.student.rules.2.sorted)
plotRules(aso.student.rules.2.sorted)
```


