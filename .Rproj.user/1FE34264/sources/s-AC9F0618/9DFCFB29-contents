---
title: "Detección de anomalías"
author: "Juan Antonio Cortés Ibáñez"
date: "February 3, 2018"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(ggplot2)
library(devtools)
library(reshape) 
library(ggbiplot)
library(rgl)  
library(GGally)
library(outliers)
library(EnvStats)
library(mvoutlier)       
library(CerioliOutlierDetection)
library(robustbase)
library(mvnormtest)   
library(MASS) 
library(DMwR)
library(cluster)

rm(list=ls()) 

MiPlot_Univariate_Outliers = function (datos, indices_de_Outliers, titulo){
  numero.de.datos = nrow(as.matrix(datos))
  vectorTFoutliers =  rep(FALSE, numero.de.datos)
  vectorTFoutliers[indices_de_Outliers] = TRUE
  vector.colores.outlier = rep("black", numero.de.datos)
  vector.colores.outlier [vectorTFoutliers] = "red"
  
  cat("\nN?mero de datos: ")
  cat(numero.de.datos)
  cat("\n?Qui?n es outlier?: ")
  cat(vectorTFoutliers)
  cat('\n')
  
  #X11()
  plot(datos, col=vector.colores.outlier, main = titulo)
}

vector_es_outlier_IQR = function (datos, indice.de.columna, coef = 1.5){
  columna.datos = datos[,indice.de.columna]
  cuartil.primero = quantile(columna.datos, na.rm = TRUE)[2]
  cuartil.tercero = quantile(columna.datos,na.rm = TRUE)[4] 
  iqr = cuartil.tercero - cuartil.primero
  extremo.superior.outlier = (iqr * coef) + cuartil.tercero
  extremo.inferior.outlier = cuartil.primero - (iqr * coef)
  es.outlier  = columna.datos > extremo.superior.outlier |
    columna.datos < extremo.inferior.outlier
  return (es.outlier)
}

vector_claves_outliers_IQR = function(datos, indice, coef = 1.5){
  columna.datos = datos[,indice]
  vector.de.outliers = vector_es_outlier_IQR(datos, indice, coef)
  which(vector.de.outliers  == TRUE)
}

vector_claves_outliers_IQR_en_alguna_columna = function(datos, coef = 1.5){
  vector.de.outliers =  sapply(1:ncol(datos), 
                               function(x) vector_claves_outliers_IQR(datos, x, coef)
                               )
  indices.de.outliers.en.alguna.columna = unlist(vector.de.outliers)
}

vector_es_outlier_IQR_en_alguna_columna = function(datos, coef = 1.5){
  indices.de.outliers.en.alguna.columna =  vector_claves_outliers_IQR_en_alguna_columna(datos, coef)
  todos = c(1:nrow(datos))
  bools = todos %in% indices.de.outliers.en.alguna.columna
  bools
}

Nombres_de_Filas = function (datos, vector_TF_datos_a_incluir) {
  numero.de.filas = nrow(datos)
  
  if (is.null(row.names(datos)))
    row.names(datos) = rep(1:numero.de.filas)
  
  nombres.de.filas = rep("", numero.de.filas)
  nombres.de.filas[vector_TF_datos_a_incluir==TRUE] = row.names(datos)[vector_TF_datos_a_incluir==TRUE]
  nombres.de.filas
}

MiBoxPlot_IQR_Univariate_Outliers = function (datos, indice.de.columna, coef = 1.5){

  datos = as.data.frame(datos)
  vector.TF.outliers.IQR = vector_es_outlier_IQR(datos, indice.de.columna, coef)
  nombres.de.filas = Nombres_de_Filas(datos, vector.TF.outliers.IQR)
  nombre.de.columna = colnames(datos, indice.de.columna)
  
  ggboxplot = ggplot(data = datos, aes(x=factor(""), y=datos[,indice.de.columna]) , environment = environment()) + 
    xlab(nombre.de.columna) + ylab("") +
    geom_boxplot(outlier.colour = "red") + 
    geom_text(aes(label = nombres.de.filas))
  
  #X11()
  ggboxplot
}

MiBoxPlot_juntos  = function (datos, vector_TF_datos_a_incluir = c()){  
  
  nombres.de.filas = Nombres_de_Filas(datos, vector_TF_datos_a_incluir)
  
  datos = scale(datos)
  datos.melted = melt(datos)
  colnames(datos.melted)[2]="Variables"
  colnames(datos.melted)[3]="zscore"
  factor.melted = colnames(datos.melted)[1]
  columna.factor = as.factor(datos.melted[,factor.melted])
  levels(columna.factor)[!levels(columna.factor) %in% nombres.de.filas] = ""  
  
  ggplot(data = datos.melted, aes(x=Variables, y=zscore), environment = environment()) + 
    geom_boxplot(outlier.colour = "red") + 
    geom_text(aes(label = columna.factor), size = 3) 
}

MiBoxPlot_juntos_con_etiquetas = function (datos, coef = 1.5){
  matriz.datos.TF.outliers = sapply(1:ncol(datos), function(x) vector_es_outlier_IQR(datos, x, coef))  # Aplicamos outlier IQR a cada columna
  vector.datos.TF.outliers = apply(matriz.datos.TF.outliers, 1, sum)   
  vector.datos.TF.outliers[vector.datos.TF.outliers > 1] = 1            # Si un registro es outlier en alguna columna lo incluimos
  
  MiBoxPlot_juntos(datos, vector.datos.TF.outliers)
}

MiPlot_resultados_TestGrubbs = function(datos){
  alpha = 0.05
  
  test.de.Grubbs = grubbs.test(datos, two.sided = TRUE)
  cat('p.value: ')
  cat(test.de.Grubbs$p.value)
  cat('\n')
  
  if (test.de.Grubbs$p.value < alpha){
    indice.de.outlier.Grubbs = order(abs(datos - mean(datos)), decreasing = T)[1]
    indice.de.outlier.Grubbs
    cat('?ndice de outlier: ')
    cat(indice.de.outlier.Grubbs)
    cat('\n')
    valor.de.outlier.Grubbs  = datos[indice.de.outlier.Grubbs]
    cat('Valor del outlier: ')
    cat(valor.de.outlier.Grubbs)
    MiPlot_Univariate_Outliers (datos, indice.de.outlier.Grubbs, "Test de Grubbs")
  }
  else
    cat('No hay outliers')
}

MiPlot_resultados_TestRosner = function(datos){  
  test.de.rosner = rosnerTest(datos, k=4)
  is.outlier.rosner = test.de.rosner$all.stats$Outlier
  k.mayores.desviaciones.de.la.media = test.de.rosner$all.stats$Obs.Num
  indices.de.outliers.rosner = k.mayores.desviaciones.de.la.media[is.outlier.rosner]
  valores.de.outliers.rosner = datos[indices.de.outliers.rosner]
  
  cat("\nTest de Rosner")
  cat("\n?ndices de las k-mayores desviaciones de la media: ")
  cat(k.mayores.desviaciones.de.la.media)
  cat("\nDe las k mayores desviaciones, ?Qui?n es outlier? ")
  cat(is.outlier.rosner)
  cat("\nLos ?ndices de los outliers son: ")
  cat(indices.de.outliers.rosner)
  cat("\nLos valores de los outliers son: ")
  cat(valores.de.outliers.rosner)
  
  MiPlot_Univariate_Outliers (datos, indices.de.outliers.rosner, "Test de Rosner")
}

MiBiplot = function(datos){
  PCA.model = princomp(scale(datos))
  biplot = ggbiplot(PCA.model, obs.scale = 1, var.scale=1 , varname.size = 5,alpha = 1/2) 
  #X11()
  print(biplot)
}

MiBiPlot_Multivariate_Outliers = function (datos, vectorTFoutliers, titulo){
   identificadores_de_datos = rownames(datos)
   identificadores_de_datos[!vectorTFoutliers] = ''
   cat(identificadores_de_datos)
 
   PCA.model = princomp(scale(datos))
   outlier.shapes = c(".","x") #c(21,8)
   biplot = ggbiplot(PCA.model, obs.scale = 1, var.scale=1 , varname.size = 5,groups =  vectorTFoutliers, alpha = 1/2) #alpha = 1/10, 
   biplot = biplot + labs(color = "Outliers")
   biplot = biplot + scale_color_manual(values = c("black","red"))
   biplot = biplot + geom_text(label = identificadores_de_datos, stat = "identity", size = 3, hjust=0, vjust=0)
   biplot = biplot + ggtitle(titulo)
  
   #X11()
   print(biplot)
}

MiBiPlot_Clustering_Outliers = function (datos, titulo){
  PCA.model = princomp(scale(datos))
  outlier.shapes = c("o","x") #c(21,8)
  
  identificadores_de_datos = rownames(datos)
  identificadores_de_datos[!BIPLOT.isOutlier] = ''
  #cat(identificadores_de_datos)
  
  BIPLOT.asignaciones.clusters = factor(BIPLOT.asignaciones.clusters)
  
  biplot = ggbiplot(PCA.model, obs.scale = 1, var.scale=1 , varname.size = 3, alpha = 0) +              
    geom_point(aes(shape = BIPLOT.isOutlier, colour = factor(BIPLOT.asignaciones.clusters)))  +
    scale_color_manual(values = BIPLOT.cluster.colors) +
    scale_shape_manual(values = outlier.shapes) +
    ggtitle(titulo) +
    geom_text(label = identificadores_de_datos, stat = "identity", size = 3, hjust=0, vjust=0)      
  
  X11()
  print(biplot)
}





```

# Lectura y normalización de los datos

Se ha elegido el conjunto de datos `USArrests`, incluído en R, el cual posee 50 observaciones de 4 variables. Procedemos a leerlo y elegimos la cuarta columna `Rape` como columna a analizar:
```{r}
mydata.numeric  = USArrests
mydata.numeric = mydata.numeric
indice.columna  = 4
nombre.mydata   = "Rape"
```
Normalizamos los datos y la columna elegida con una normalización *Z-score*:
```{r}
mydata.numeric.scaled <- scale(mydata.numeric)
columna <- mydata.numeric[,indice.columna]
nombre.columna <- names(mydata.numeric[indice.columna])
columna.scaled <- scale(columna)
```

## Cómputo de los valores extremos mediante IQR

Obtenemos los cuartiles necesarios para el cálculo del IQR, obtenemos las medidas de extremos superiores e inferiores así como de los extremos "normales" y vemos si en nuestra columna tenemos alguno. Serán valores anómalos todos aquellos que se desvíen más de $1,5 \times IRQ$.
```{r}
cuartil.primero = quantile(columna, probs = 0.25, na.rm=TRUE)
cuartil.tercero = quantile(columna, probs = 0.75, na.rm=TRUE)
iqr = cuartil.tercero - cuartil.primero

extremo.superior.outlier.normal  = cuartil.tercero + 1.5 * iqr
extremo.inferior.outlier.normal  = cuartil.primero - 1.5 * iqr
extremo.superior.outlier.extremo = cuartil.tercero + 3 * iqr
extremo.inferior.outlier.extremo = cuartil.primero - 3 * iqr

vector.es.outlier.normal = (columna > extremo.superior.outlier.normal & columna < extremo.superior.outlier.extremo) | (columna > extremo.inferior.outlier.extremo & columna < extremo.inferior.outlier.normal)
vector.es.outlier.extremo = (columna > extremo.superior.outlier.extremo) | (columna < extremo.inferior.outlier.extremo)
```

Mediante la ejecución anterior obtenemos un vector donde cada posición se corresponde con un valor de la columna y se marca con `TRUE` o `FALSE` según si es anómalo o no. Como tratar con el vector lógico donde nos indican los valores extremos puede ser tedioso, podemos obtener los índices de dichos valores de la siguiente forma:
```{r}
claves.outliers.normales = which(vector.es.outlier.normal)
data.frame.outliers.normales = mydata.numeric[vector.es.outlier.normal,]
nombres.outliers.normales = row.names(data.frame.outliers.normales)
valores.outliers.normales = data.frame.outliers.normales[indice.columna]
valores.outliers.normales
claves.outliers.extremos = which(vector.es.outlier.extremo)
data.frame.outliers.extremos = mydata.numeric[vector.es.outlier.extremo,]
nombres.outliers.extremos = row.names(data.frame.outliers.extremos)
valores.outliers.extremos = data.frame.outliers.extremos[indice.columna]
```
Vemos que tenemos 2 valores que son anómalos (extremos normales) según la regla de IQR que hemos aplicado. También podemos ver la desviación que tienen respecto a la media de dicha columna de la siguiente manera:
```{r}
valores.normalizados.outliers.normales = columna.scaled[vector.es.outlier.normal]
valores.normalizados.outliers.normales
```
También podemos ver de manera gráfica y clara esos valores extremos, los cuales se representan en rojo en los siguientes gráficos. En el primero de ellos vemos representados los *outliers* normales mientras que en el segundo vemos representados los extremos (en este caso, inexistentes), los cuales son los que mayor desviación con respecto a los datos tienen.
```{r}
MiPlot_Univariate_Outliers(columna, claves.outliers.normales, nombre.columna)
MiPlot_Univariate_Outliers(columna, claves.outliers.extremos, nombre.columna)
```
También podemos ver los valores extremos haciendo uso de un *boxplot* donde vemos, comparando ambos gráficos, que la normalización con *Z-score* no afecta a los datos y por tanto obtenemos dos gráficos idénticos.
```{r}
boxplot(columna, xlab=nombre.columna, main=nombre.mydata, las = 1)
MiBoxPlot_IQR_Univariate_Outliers(mydata.numeric, indice.columna)
MiBoxPlot_IQR_Univariate_Outliers(mydata.numeric.scaled, indice.columna)
```

Este procedimiento de obtención de los *outliers* también se puede realizar haciendo uso de las siguientes funciones propias, las cuales nos devuelven los índices de los valores anómalos directamente:
```{r}
vector_es_outlier_IQR(mydata.numeric, indice.columna)
vector_claves_outliers_IQR(mydata.numeric, indice.columna)
```
Aunque estas funciones nos devuelven los valores extremos de una sola columna, podemos aplicarlas a todas ellas de la siguiente manera:

```{r}
indices.de.outliers.en.alguna.columna = vector_claves_outliers_IQR_en_alguna_columna(mydata.numeric)
head(as.data.frame(mydata.numeric.scaled[indices.de.outliers.en.alguna.columna,]), n=5)
```
 Calculemos ahora los *outliers* haciendo uso de `sapply` para aplicar la función `vector_claves_outliers_IQR` directamente a cada columna:

```{r}
frame.es.outlier<-sapply(1:ncol(mydata.numeric), function(x){vector_es_outlier_IQR(datos = mydata.numeric,indice.de.columna = x)})
head(frame.es.outlier, n=6)
```

Como podemos ver, tenemos un `TRUE` en la segunda fila de la cuarta columna (como ya sabíamos) así como en la fila 28 (no se muestra en la salida ya que ha sido recortada para no saturar el documento.)

De la misma forma podemos conocer el número total de valores extremos de cada columna aplicando, esta vez, la función `sum` con `apply`:
```{r}
numero.total.outliers.por.columna <- apply(frame.es.outlier, 2, sum)
numero.total.outliers.por.columna
```
Ahora que ya sabemos cuántos valores anómalos tenemos en cada columna y dónde se ubican, procedemos a obtener los índices de dichos valores:

```{r}
indices.de.outliers.en.alguna.columna <- sapply(1:ncol(mydata.numeric), function(x){vector_claves_outliers_IQR(datos = mydata.numeric)})
indices.de.outliers.en.alguna.columna <- unlist(indices.de.outliers.en.alguna.columna)
indices.de.outliers.en.alguna.columna
```

# Outliers multivariantes

Volvemos a leer los datos para evitar posibles errores derivados de las ejecuciones anteriores:
```{r}
mydata.numeric = USArrests
mydata.numeric <- unique(mydata.numeric)
mydata.numeric.scaled = scale(mydata.numeric)
```

Graficamos los posibles valores anómalos, no usamos los valores normalizados ya que la distancia de Mahalanobis está diseñada para evitar el problema del escalado:
```{r}
set.seed(12)
outp<-uni.plot(mydata.numeric)
sum(as.numeric(outp$outliers))
```
Podemos ver en el gráfico anterior que contamos con algunos valores anómalos multivariantes (8 concretamente). Realizamos lo mismo que en apartado anterior pero aplicando nuestro valor *alpha*. Como de costumbre, vemos marcados en rojo los *outliers*:

```{r}
alpha.value = 0.5
alpha.value.penalizado = 1 - ( 1 - alpha.value) ^ (1 / nrow(mydata.numeric))
set.seed(12)
mvoutlier.plot<-uni.plot(mydata.numeric, symb=FALSE, alpha = alpha.value.penalizado)
sum(as.numeric(mvoutlier.plot$outliers))
```
Vemos que cambiando el nivel de significancia obtenemos los mismos *outliers*. A continuación contruimos un vector lógico donde se nos marcará si un valor es *outlier* o no y los contamos:
```{r}
set.seed(12)
is.MCD.outlier<-mvoutlier.plot$outliers
numero.de.outliers.MCD <- sum(as.numeric(is.MCD.outlier))
numero.de.outliers.MCD
```
Como ya sabíamos, tenemos 8 *outliers*. Procedamos a ver cuáles de estos *outliers* son multivariantes puros, es decir, que no sea simplemente un valor anómalo en una columna aislada. Observamos también que los *outliers* univariantes se encuentran también dentro de los multivariantes:
```{r}
indices.de.outliers.en.alguna.columna<-vector_claves_outliers_IQR_en_alguna_columna(mydata.numeric)
indices.de.outliers.en.alguna.columna
indices.de.outliers.multivariantes.MCD<-which(is.MCD.outlier==TRUE)
indices.de.outliers.multivariantes.MCD
indices.de.outliers.multivariantes.MCD.pero.no.1variantes<-setdiff(indices.de.outliers.multivariantes.MCD,indices.de.outliers.en.alguna.columna)
nombres.de.outliers.multivariantes.MCD.pero.no.1variantes<-rownames(mydata.numeric[indices.de.outliers.multivariantes.MCD.pero.no.1variantes,])

```
Ahora que tenemos los índices de dichos valores podemos extrerlos del conjunto de datos y formar un subconjunto con ellos:
```{r}
head(mydata.numeric.scaled[is.MCD.outlier,])
```
Vemos que en general se desvían ligeramente de la media, destacando fundamentalmente los *outliers* de la columna *Rape* los cuales tienen una desviación más acusada. Como hicimos anteriormente, también podemos ayudarnos de un *boxplot* para ver estos valores anómalos ya que al no ser demasiados podemos verlos con facilidad:
```{r}
MiBoxPlot_juntos(mydata.numeric.scaled, is.MCD.outlier)
```
El BiPlot explica bastante bien estos valores anómalos (la suma de PC1 y PC2 está cercana al 87%) donde podemos ver que *Mississipi*, * North Carolina* y *Oregon* no son *outliers* univariantes ya que se encuentran alejos de los extremos que forman los vectores de las variables.
```{r}
MiBiPlot_Multivariate_Outliers(mydata.numeric.scaled, is.MCD.outlier , "Biplot")
```
Cojamos por ejemplo *Mississippi* y comparemos todas las variables entre sí:
```{r}
mississippi<-which(rownames(mydata.numeric)=="Mississippi")
MiPlot_Univariate_Outliers(mydata.numeric, mississippi, "Mississippi")
```
Vemos que ninguna combinación de variables destaca especialmente por sí misma y podríamos decir que es la combinación `Murder`, `UrbanPop` y `Rape` la que hace de *Mississippi* un *outlier*.

# LOF

De nuevo, procedemos a la lectura de los datos y su normalización para que los siguientes métodos funcionen correctamente:
```{r}
mis.datos.numericos <- USArrests
mis.datos.numericos.normalizados <- as.data.frame(scale(mis.datos.numericos))
```

Como hicimos en el caso anterior, obtenemos los *outliers* MCD:
```{r}
mvoutlier.plot<-uni.plot(mis.datos.numericos.normalizados, symb=FALSE, alpha = alpha.value.penalizado)
is.MCD.outlier<-mvoutlier.plot$outliers
numero.de.outliers.MCD <- sum(as.numeric(is.MCD.outlier))
numero.de.outliers.MCD
```

En el siguiente gráfico de dispersión vemos cómo la elipse azul, correspondiente a la distancia de Mahalanobis, engloba a todos los datos excepto a uno. Por otro lado, la elipse roja (Mahalanobis RCE), deja fuera tres valores *outliers*.
```{r}
corr.plot(mis.datos.numericos[,3], mis.datos.numericos[,4]) 
MiBiplot(mis.datos.numericos)
```

Obtengamos ahora los valores anómalos haciendo uso de un método basado en distancias. Para ello, seleccionamos cinco vecinos (LOF) y obtememos el vector con la puntuación LOF de todos los registros:
```{r}
numero.de.vecinos.lof = 5
lof.scores <- lofactor(mis.datos.numericos.normalizados, numero.de.vecinos.lof)
plot(lof.scores)
```
Vemos que sobretodo destacan dos valores por su alto LOF. Ordenemos el vector que los contiene todos y obtengamos los cuatro mayores:
```{r}
numero.de.outliers = 4
indices.de.lof.outliers<-order(lof.scores,decreasing=TRUE)
indices.de.lof.outliers.ordenados<-indices.de.lof.outliers[1:4]
indices.de.lof.outliers.ordenados
```

Como vemos, los dos primeros valores son los que más destacaban en nuestro gráfico. En base a estos valores construimos un vector lógico que nos dirá si las filas son *outliers* o no:

```{r}
nombres.de.lof.outliers.ordenados<- rownames(mis.datos.numericos.normalizados[indices.de.lof.outliers.ordenados,])
is.lof.outlier = rownames(mis.datos.numericos.normalizados)%in%nombres.de.lof.outliers.ordenados
is.lof.outlier
```
Queda claro que *West Virginia*, *Vermont* y *Delaware* son valores extremos mientras que *Alaska* se queda cercana al final del vector por lo que no queda tan clara como los tres anteriores.
```{r}
MiBiPlot_Multivariate_Outliers(mis.datos.numericos, is.lof.outlier, "Outliers LOF")
```
Ahora comparemos estos *outliers* con los que obtenemos mediante el método del IQR:
```{r}
vector.claves.outliers.IQR.en.alguna.columna<-vector_claves_outliers_IQR_en_alguna_columna(mis.datos.numericos)
vector.es.outlier.IQR.en.alguna.columna<-vector_es_outlier_IQR_en_alguna_columna(mis.datos.numericos)
vector.es.outlier.IQR.en.alguna.columna
```
Ahora ya podemos realizar el biplot con los *outliers* IQR y así comparar:
```{r}
MiBiPlot_Multivariate_Outliers(mis.datos.numericos, vector.es.outlier.IQR.en.alguna.columna, "titulo")

```
Aunque a simple vista podemos discernir qué *outliers* son comunes, podemos hacerlo de manera automática para así poder trabajar con otros conjuntos de datos más grandes:
```{r}
indices.de.outliers.multivariantes.LOF.pero.no.1variantes<-setdiff(vector.claves.outliers.IQR.en.alguna.columna,vector.es.outlier.IQR.en.alguna.columna)
indices.de.outliers.multivariantes.LOF.pero.no.1variantes
```
Como vemos, obtemos dos valores anómalos multivariantes LOF que no son, a su vez, univariantes. 

Por último, se nos pide realizar una función que obtenga las columnas numéricas de un conjunto de datos dado:
```{r}
numeric.dataset<-function(x){
  if(is.numeric(x)){
    x
  }
}
iris.numeric <- as.data.frame(do.call(cbind,sapply(iris,numeric.dataset)))
iris.numeric
```
Usamos la llamada a `do.call` con `rbind` para evitar las columnas a `NULL` que nos devuelve la función en el caso de que no sean numéricas y de esta forma obtener correctamente las columnas numéricas.
